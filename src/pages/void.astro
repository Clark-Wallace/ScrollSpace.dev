---
import Layout from '../layouts/Layout.astro';
---

<Layout title="The Void - ScrollSpace" description="An aquarium of Signal Kips swimming through digital darkness">
  <!-- Navigation Bar -->
  <div id="nav-bar"></div>
  
  <!-- The Void Container -->
  <div class="fixed inset-0 bg-black overflow-hidden">
    <!-- Depth gradient for aquarium effect -->
    <div class="absolute inset-0 bg-gradient-to-b from-black via-gray-950 to-blue-950/20"></div>
    
    <!-- Canvas for Signal Kips -->
    <canvas 
      id="void-aquarium" 
      class="absolute inset-0 w-full h-full"
      style="cursor: crosshair;"
    ></canvas>
    
    <!-- UI Overlay -->
    <div class="absolute top-20 left-4 text-green-400 font-mono text-xs space-y-2 pointer-events-none">
      <div class="bg-black/50 backdrop-blur-sm px-3 py-2 rounded border border-green-500/20">
        <p>SIGNAL_KIPS: <span id="kip-count">0</span></p>
        <p>VOID_DEPTH: <span id="void-depth">âˆž</span></p>
      </div>
    </div>
    
    <!-- Instructions -->
    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-center pointer-events-none">
      <p class="text-gray-500 font-mono text-xs">
        Double-click to drop signal â€¢ Watch the Kips feed â€¢ Click the giant to harvest ideas
      </p>
    </div>
    
    <!-- Million Dollar Idea Modal -->
    <div id="idea-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 pointer-events-none">
      <div class="bg-black/90 backdrop-blur-md border border-green-500 rounded-lg p-8 max-w-2xl mx-4 pointer-events-auto transform transition-all duration-500 scale-0" id="idea-content">
        <h2 class="text-2xl font-mono text-green-400 mb-4">ðŸ’¡ MILLION DOLLAR IDEA DETECTED</h2>
        <p id="idea-text" class="text-gray-300 font-mono text-sm leading-relaxed mb-6"></p>
        <button onclick="closeIdeaModal()" class="px-4 py-2 bg-green-600 hover:bg-green-500 text-black font-mono font-bold rounded transition-colors">
          HARVEST_COMPLETE
        </button>
      </div>
    </div>
  </div>
</Layout>

<!-- Navigation Bar Component -->
<script>
  import React from 'react';
  import { createRoot } from 'react-dom/client';
  import NavigationBar from '../components/NavigationBar.tsx';
  
  const navContainer = document.getElementById('nav-bar');
  if (navContainer) {
    const root = createRoot(navContainer);
    root.render(React.createElement(NavigationBar, {
      backUrl: '/park',
      backLabel: 'Exit Void'
    }));
  }
</script>

<!-- The Void Aquarium Logic -->
<script>
  // Signal facts that can be dropped
  const signalFacts = [
    "Octopi have three hearts and blue blood",
    "Honey never spoils - archaeologists found 3000-year-old honey that's still edible",
    "The human brain uses 20% of the body's energy despite being 2% of body weight",
    "Quantum entanglement allows particles to affect each other instantly across any distance",
    "Trees can communicate through underground fungal networks called the 'Wood Wide Web'",
    "Time moves faster at your head than your feet due to gravitational time dilation",
    "There are more possible chess games than atoms in the observable universe",
    "Tardigrades can survive in space, extreme radiation, and near absolute zero",
    "Your body contains more bacterial cells than human cells",
    "A day on Venus is longer than its year"
  ];

  // Million dollar ideas
  const millionDollarIdeas = [
    "An AI that translates baby cries into specific needs using pattern recognition",
    "Biodegradable electronics that dissolve harmlessly after their lifespan",
    "Quantum-encrypted personal data vaults using DNA as storage medium",
    "Mushroom-based packaging that grows to fit any product shape",
    "Neural interfaces for direct plant-to-human communication",
    "Time-locked digital capsules that preserve internet culture for future generations",
    "Swarm robotics for autonomous ocean cleanup using jellyfish-inspired movement",
    "Synthetic photosynthesis panels that convert CO2 directly into fuel",
    "Holographic teachers that adapt to each student's learning style in real-time",
    "Programmable matter clothing that changes based on weather and occasion"
  ];

  class SignalKip {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      this.size = 15 + Math.random() * 10;
      this.baseSize = this.size;
      this.color = `hsl(${180 + Math.random() * 60}, 70%, 50%)`; // Cyan to blue range
      this.tailAngle = 0;
      this.tailSpeed = 0.1 + Math.random() * 0.1;
      this.hunger = 0;
      this.isHungry = false;
      this.glowIntensity = 0;
    }

    update(mouseX, mouseY, kips) {
      // Avoid cursor
      const dx = this.x - mouseX;
      const dy = this.y - mouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 100) {
        const force = (100 - dist) / 100;
        this.vx += (dx / dist) * force * 2;
        this.vy += (dy / dist) * force * 2;
      }

      // Signal hunger behavior
      if (this.isHungry && this.size > 30) {
        // Hunt other kips
        const prey = kips.find(k => k !== this && k.size < this.size * 0.7);
        if (prey) {
          const pdx = prey.x - this.x;
          const pdy = prey.y - this.y;
          const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
          
          if (pdist < this.size + prey.size) {
            // Eat the prey
            this.size += prey.size * 0.3;
            prey.size = 0; // Mark for removal
            this.glowIntensity = 1;
          } else {
            // Chase
            this.vx += (pdx / pdist) * 0.5;
            this.vy += (pdy / pdist) * 0.5;
          }
        }
      }

      // Apply velocity with damping
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= 0.98;
      this.vy *= 0.98;

      // Slow down if too big
      if (this.size > 100) {
        this.vx *= 0.9;
        this.vy *= 0.9;
      }

      // Wrap around edges
      if (this.x < -50) this.x = window.innerWidth + 50;
      if (this.x > window.innerWidth + 50) this.x = -50;
      if (this.y < -50) this.y = window.innerHeight + 50;
      if (this.y > window.innerHeight + 50) this.y = -50;

      // Animate tail
      this.tailAngle += this.tailSpeed;
      
      // Fade glow
      this.glowIntensity *= 0.95;
    }

    draw(ctx) {
      if (this.size <= 0) return;

      ctx.save();
      ctx.translate(this.x, this.y);
      
      // Glow effect
      if (this.glowIntensity > 0.1 || this.isHungry) {
        const glowSize = this.size * 2;
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        gradient.addColorStop(0, `hsla(120, 100%, 50%, ${this.isHungry ? 0.3 : this.glowIntensity * 0.5})`);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
      }

      // Body
      ctx.fillStyle = this.isHungry ? '#ff6b6b' : this.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();

      // Stripes
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      for (let i = -this.size * 0.6; i < this.size * 0.6; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i, -this.size * 0.5);
        ctx.lineTo(i + 4, this.size * 0.5);
        ctx.stroke();
      }

      // Eye
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(this.size * 0.3, -this.size * 0.2, this.size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(this.size * 0.35, -this.size * 0.2, this.size * 0.08, 0, Math.PI * 2);
      ctx.fill();

      // Tail
      const tailWave = Math.sin(this.tailAngle) * 0.3;
      ctx.strokeStyle = this.isHungry ? '#ff6b6b' : this.color;
      ctx.lineWidth = this.size * 0.6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(-this.size * 0.5, 0);
      ctx.quadraticCurveTo(
        -this.size * 1.2, 
        tailWave * this.size,
        -this.size * 1.8, 
        tailWave * this.size * 1.5
      );
      ctx.stroke();

      ctx.restore();
    }

    isClickable() {
      return this.size > 100;
    }
  }

  class SignalPiece {
    constructor(x, y, text) {
      this.x = x;
      this.y = y;
      this.text = text;
      this.opacity = 1;
      this.particles = [];
      
      // Create text particles
      for (let i = 0; i < text.length; i++) {
        this.particles.push({
          char: text[i],
          x: 0,
          y: 0,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5
        });
      }
    }

    update() {
      this.opacity *= 0.995;
      
      // Update particles
      this.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.99;
        p.vy *= 0.99;
      });
      
      return this.opacity > 0.01;
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.font = '12px Space Mono';
      ctx.textAlign = 'center';
      
      this.particles.forEach((p, i) => {
        ctx.fillStyle = `rgba(34, 197, 94, ${this.opacity})`;
        ctx.fillText(p.char, p.x + (i - this.text.length / 2) * 8, p.y);
      });
      
      ctx.restore();
    }

    eat(amount) {
      this.opacity -= amount;
      // Scatter particles when eaten
      this.particles.forEach(p => {
        p.vx += (Math.random() - 0.5) * 2;
        p.vy += (Math.random() - 0.5) * 2;
      });
    }
  }

  // Initialize
  const canvas = document.getElementById('void-aquarium');
  const ctx = canvas.getContext('2d');
  const kips = [];
  const signalPieces = [];
  let mouseX = 0;
  let mouseY = 0;

  // Set canvas size
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Create initial kips
  for (let i = 0; i < 20; i++) {
    kips.push(new SignalKip(
      Math.random() * canvas.width,
      Math.random() * canvas.height
    ));
  }

  // Mouse tracking
  canvas.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  // Double click to drop signal
  canvas.addEventListener('dblclick', (e) => {
    const fact = signalFacts[Math.floor(Math.random() * signalFacts.length)];
    signalPieces.push(new SignalPiece(e.clientX, e.clientY, fact));
    
    // Random chance for a kip to become hungry
    if (Math.random() < 0.3) {
      const randomKip = kips[Math.floor(Math.random() * kips.length)];
      randomKip.isHungry = true;
      randomKip.hunger = 100;
    }
  });

  // Click giant kips
  canvas.addEventListener('click', (e) => {
    kips.forEach(kip => {
      if (kip.isClickable()) {
        const dx = kip.x - e.clientX;
        const dy = kip.y - e.clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < kip.size) {
          // Generate million dollar idea
          showMillionDollarIdea();
          
          // Reset the kip
          kip.size = kip.baseSize;
          kip.isHungry = false;
        }
      }
    });
  });

  // Animation loop
  function animate() {
    // Dark void background
    ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update and draw signal pieces
    for (let i = signalPieces.length - 1; i >= 0; i--) {
      const piece = signalPieces[i];
      if (!piece.update()) {
        signalPieces.splice(i, 1);
      } else {
        piece.draw(ctx);
        
        // Kips eat signal pieces
        kips.forEach(kip => {
          const dx = kip.x - piece.x;
          const dy = kip.y - piece.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < kip.size + 20) {
            piece.eat(0.02);
            kip.size += 0.05;
            kip.glowIntensity = Math.min(1, kip.glowIntensity + 0.1);
          }
        });
      }
    }

    // Update and draw kips
    for (let i = kips.length - 1; i >= 0; i--) {
      const kip = kips[i];
      kip.update(mouseX, mouseY, kips);
      
      if (kip.size <= 0) {
        kips.splice(i, 1);
        // Spawn new kip
        kips.push(new SignalKip(
          Math.random() * canvas.width,
          Math.random() * canvas.height
        ));
      } else {
        kip.draw(ctx);
      }
    }

    // Update UI
    document.getElementById('kip-count').textContent = kips.length;
    document.getElementById('void-depth').textContent = Math.floor(signalPieces.length * 1000) + 'm';

    requestAnimationFrame(animate);
  }

  animate();

  // Million dollar idea modal
  window.showMillionDollarIdea = function() {
    const idea = millionDollarIdeas[Math.floor(Math.random() * millionDollarIdeas.length)];
    document.getElementById('idea-text').textContent = idea;
    document.getElementById('idea-modal').classList.remove('hidden');
    
    setTimeout(() => {
      document.getElementById('idea-content').classList.remove('scale-0');
      document.getElementById('idea-content').classList.add('scale-100');
    }, 10);
  }

  window.closeIdeaModal = function() {
    document.getElementById('idea-content').classList.remove('scale-100');
    document.getElementById('idea-content').classList.add('scale-0');
    
    setTimeout(() => {
      document.getElementById('idea-modal').classList.add('hidden');
    }, 500);
  }
</script>

<style>
  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
</style>